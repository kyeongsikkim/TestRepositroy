오류의 조유
에러
하드웨어의 오동작 또는 고장으로 인한 오류
예외
사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인한 오류
예외가 발생되면 시스템 종료
예외처리하면 정상 실행 상태로 돌아 갈 수있음

일반예외
컴파일이 되지 않는 예외
예외가 발생될거같다 하는 코드에 

실행예외
컴파일러가 체크를 하지 않지만 그런 예외.

java.lang.Exception 을 상속받게 되어있다.
컴파일러가 체크를 하는 것 
runtime Exception 을 통해 만든 것도있다.

java.lang.Object
java.lang.Throwable
java.lang.Exception
java.lang.RuntimeException
java.lang.ArithmeticException 이것은 순서대로 상속 받은 것이다. 즉 실행 예외
Null pointer Exception
객체 참조가 없는 상태,즉 null 값을 갖는 참조변수로 객체 접근 연사자인 도트를 사용했을대 발생
String xx=null
syso(xx.toString());nul exception 발생한다.

integer.parseInt(data1);
integer 클래스이고 parseInt 는 메소드인데 스태틱 메소드이다 객체를 생성안하고 사용 하였기 때문에
static 의 메소드는 클래스이름 붙이고서.메소드이름

클래스 이름을 먼저 찾는다 몇번째에서 에러가 났는지 먼저 찾는다.

실행 예외는 컴파일러가 체크를 안한다.
점선은 구현이구 실선은 ??
클래스 캐스팅 익셉션 : 타입 변환을 잘못했다.
예외 처리 코드는 예외가 발생하면 프로그램 종료를 막고 정상실행 을 유지할 수있는것

일반예외
keycode 같은 경우

예외 처리하는 방법 try-cathch- finally 예외를 잡는 다는 것은 예외처리를 하겠다.

내가 만들지 않은 클래스를 가지고와서 사용할 경우 
메소드 호출 할 경우 
int result=xx.method();일 경우 
Class class=class.ForName();//컴파일이 안된다 잘못실행할경우 예외가 발생할수도있으니까 try catch 를 사용해야 된다.

try{
	Class class=Class.forNmae();
	}catch(xxxException e){
	}
	
	보통 메소드를 선언할때
	int method() throws xxxException{
	이안에 실행을 잘못하게 하면은 xxx 예외가 발생을 한다.
	그럼 왜안에서 발생할 수 있는데 안에서 try catch 를 왜 안잡았나
	
	 throws 는 예외가 발생할 수 있다고 알려주는 것이다. 그러나 나는 try catch 를 안에서 처리 안하겠다.
	 대신에 나를 호출한 사람 한테 예외처리를 넘기겠다. 
	 사람마다 예외 처리하는게 달라서 각자 한테 맡긴다. throws 로 예외가 발생할 수있다고 알려주는 정도 
	}
	실행을 못하게 되면 예외 처리가 발생된다. 메소드 뒤에보면은 
	
	runtime exception 같은 경우는 컴파일러가 검사를 안한다.
	classNotFoundException 은 위로 올라가도 runtimeException 이 없다.
	
	void method()throws AException,BException{
	AException int result=xxx.method();
	BException Class class=class.forName();
	
	method() 의 try catch 를 잡아줘야 한다.
	
	예외 처리는 두가지가 있다 throws 로 던지는 경우와 
	내가 try catch 로 잡아주는 것이다.
	